{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nexports.decode = decode;\nexports.encode = encode;\nexports.getPubKeys = getPubKeys;\nvar _bytebuffer = require('bytebuffer');\nvar _bytebuffer2 = _interopRequireDefault(_bytebuffer);\nvar _assert = require('assert');\nvar _assert2 = _interopRequireDefault(_assert);\nvar _bs = require('bs58');\nvar _bs2 = _interopRequireDefault(_bs);\nvar _ecc = require('./ecc');\nvar _serializer = require('./serializer');\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar encMemo = _serializer.ops.encrypted_memo;\n\n/**\n    Some fields are only required if the memo is marked for decryption (starts with a hash).\n    @arg {string|PrivateKey} private_key - WIF or PrivateKey object\n    @arg {string} memo - plain text is returned, hash prefix base58 is decrypted\n    @return {string} - utf8 decoded string (hash prefix)\n*/\nfunction decode(private_key, memo) {\n  (0, _assert2.default)(memo, 'memo is required');\n  _assert2.default.equal(typeof memo === 'undefined' ? 'undefined' : _typeof(memo), 'string', 'memo');\n  if (!/^#/.test(memo)) return memo;\n  memo = memo.substring(1);\n  (0, _assert2.default)(private_key, 'private_key is required');\n  checkEncryption();\n  private_key = toPrivateObj(private_key);\n  memo = _bs2.default.decode(memo);\n  memo = encMemo.fromBuffer(new Buffer(memo, 'binary'));\n  var _memo = memo,\n    from = _memo.from,\n    to = _memo.to,\n    nonce = _memo.nonce,\n    check = _memo.check,\n    encrypted = _memo.encrypted;\n  var pubkey = private_key.toPublicKey().toString();\n  var otherpub = pubkey === from.toString() ? to.toString() : from.toString();\n  memo = _ecc.Aes.decrypt(private_key, otherpub, nonce, encrypted, check);\n\n  // remove varint length prefix\n  var mbuf = _bytebuffer2.default.fromBinary(memo.toString('binary'), _bytebuffer2.default.DEFAULT_CAPACITY, _bytebuffer2.default.LITTLE_ENDIAN);\n  try {\n    mbuf.mark();\n    return '#' + mbuf.readVString();\n  } catch (e) {\n    mbuf.reset();\n    // Sender did not length-prefix the memo\n    memo = new Buffer(mbuf.toString('binary'), 'binary').toString('utf-8');\n    return '#' + memo;\n  }\n}\n\n/**\n    Some fields are only required if the memo is marked for encryption (starts with a hash).\n    @arg {string|PrivateKey} private_key - WIF or PrivateKey object\n    @arg {string|PublicKey} public_key - Recipient\n    @arg {string} memo - plain text is returned, hash prefix text is encrypted\n    @arg {string} [testNonce = undefined] - just for testing\n    @return {string} - base64 decoded string (or plain text)\n*/\nfunction encode(private_key, public_key, memo, testNonce) {\n  (0, _assert2.default)(memo, 'memo is required');\n  _assert2.default.equal(typeof memo === 'undefined' ? 'undefined' : _typeof(memo), 'string', 'memo');\n  if (!/^#/.test(memo)) return memo;\n  memo = memo.substring(1);\n  (0, _assert2.default)(private_key, 'private_key is required');\n  (0, _assert2.default)(public_key, 'public_key is required');\n  checkEncryption();\n  private_key = toPrivateObj(private_key);\n  public_key = toPublicObj(public_key);\n  var mbuf = new _bytebuffer2.default(_bytebuffer2.default.DEFAULT_CAPACITY, _bytebuffer2.default.LITTLE_ENDIAN);\n  mbuf.writeVString(memo);\n  memo = new Buffer(mbuf.copy(0, mbuf.offset).toBinary(), 'binary');\n  var _Aes$encrypt = _ecc.Aes.encrypt(private_key, public_key, memo, testNonce),\n    nonce = _Aes$encrypt.nonce,\n    message = _Aes$encrypt.message,\n    checksum = _Aes$encrypt.checksum;\n  memo = encMemo.fromObject({\n    from: private_key.toPublicKey(),\n    to: public_key,\n    nonce: nonce,\n    check: checksum,\n    encrypted: message\n  });\n  // serialize\n  memo = encMemo.toBuffer(memo);\n  return '#' + _bs2.default.encode(new Buffer(memo, 'binary'));\n}\n\n/** Get public keys of both sender and receiver */\nfunction getPubKeys(memo) {\n  (0, _assert2.default)(memo, 'memo is required');\n  _assert2.default.equal(typeof memo === 'undefined' ? 'undefined' : _typeof(memo), 'string', 'memo');\n  if (!/^#/.test(memo)) return [];\n  memo = memo.substring(1);\n  checkEncryption();\n  memo = _bs2.default.decode(memo);\n  memo = encMemo.fromBuffer(new Buffer(memo, 'binary'));\n  var _memo2 = memo,\n    from = _memo2.from,\n    to = _memo2.to;\n  return [from.toString(), to.toString()];\n}\nvar encodeTest = undefined;\n\n/**\n  Memo encryption has failed in the browser before.  An Error will be thrown\n  if a memo can't be encrypted and decrypted.\n*/\nfunction checkEncryption() {\n  if (encodeTest === undefined) {\n    var plaintext = void 0;\n    encodeTest = true; // prevent infinate looping\n    try {\n      var wif = '5JdeC9P7Pbd1uGdFVEsJ41EkEnADbbHGq6p1BwFxm6txNBsQnsw';\n      var pubkey = 'STM8m5UgaFAAYQRuaNejYdS8FVLVp9Ss3K1qAVk5de6F8s3HnVbvA';\n      var cyphertext = encode(wif, pubkey, '#memo爱');\n      plaintext = decode(wif, cyphertext);\n    } catch (e) {\n      console.error(e);\n    } finally {\n      encodeTest = plaintext === '#memo爱';\n    }\n  }\n  if (encodeTest === false) throw new Error('This environment does not support encryption.');\n}\nvar toPrivateObj = function toPrivateObj(o) {\n  return o ? o.d ? o : _ecc.PrivateKey.fromWif(o) : o /*null or undefined*/;\n};\nvar toPublicObj = function toPublicObj(o) {\n  return o ? o.Q ? o : _ecc.PublicKey.fromString(o) : o /*null or undefined*/;\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","decode","encode","getPubKeys","_bytebuffer","require","_bytebuffer2","_interopRequireDefault","_assert","_assert2","_bs","_bs2","_ecc","_serializer","__esModule","default","encMemo","ops","encrypted_memo","private_key","memo","equal","test","substring","checkEncryption","toPrivateObj","fromBuffer","Buffer","_memo","from","to","nonce","check","encrypted","pubkey","toPublicKey","toString","otherpub","Aes","decrypt","mbuf","fromBinary","DEFAULT_CAPACITY","LITTLE_ENDIAN","mark","readVString","e","reset","public_key","testNonce","toPublicObj","writeVString","copy","offset","toBinary","_Aes$encrypt","encrypt","message","checksum","fromObject","toBuffer","_memo2","encodeTest","undefined","plaintext","wif","cyphertext","console","error","Error","o","d","PrivateKey","fromWif","Q","PublicKey","fromString"],"sources":["C:/Users/sunil/kalakaari/node_modules/@hiveio/hive-js/lib/auth/memo.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.decode = decode;\nexports.encode = encode;\nexports.getPubKeys = getPubKeys;\n\nvar _bytebuffer = require('bytebuffer');\n\nvar _bytebuffer2 = _interopRequireDefault(_bytebuffer);\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _bs = require('bs58');\n\nvar _bs2 = _interopRequireDefault(_bs);\n\nvar _ecc = require('./ecc');\n\nvar _serializer = require('./serializer');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar encMemo = _serializer.ops.encrypted_memo;\n\n/**\n    Some fields are only required if the memo is marked for decryption (starts with a hash).\n    @arg {string|PrivateKey} private_key - WIF or PrivateKey object\n    @arg {string} memo - plain text is returned, hash prefix base58 is decrypted\n    @return {string} - utf8 decoded string (hash prefix)\n*/\nfunction decode(private_key, memo) {\n    (0, _assert2.default)(memo, 'memo is required');\n    _assert2.default.equal(typeof memo === 'undefined' ? 'undefined' : _typeof(memo), 'string', 'memo');\n    if (!/^#/.test(memo)) return memo;\n    memo = memo.substring(1);\n\n    (0, _assert2.default)(private_key, 'private_key is required');\n    checkEncryption();\n\n    private_key = toPrivateObj(private_key);\n\n    memo = _bs2.default.decode(memo);\n    memo = encMemo.fromBuffer(new Buffer(memo, 'binary'));\n\n    var _memo = memo,\n        from = _memo.from,\n        to = _memo.to,\n        nonce = _memo.nonce,\n        check = _memo.check,\n        encrypted = _memo.encrypted;\n\n    var pubkey = private_key.toPublicKey().toString();\n    var otherpub = pubkey === from.toString() ? to.toString() : from.toString();\n    memo = _ecc.Aes.decrypt(private_key, otherpub, nonce, encrypted, check);\n\n    // remove varint length prefix\n    var mbuf = _bytebuffer2.default.fromBinary(memo.toString('binary'), _bytebuffer2.default.DEFAULT_CAPACITY, _bytebuffer2.default.LITTLE_ENDIAN);\n    try {\n        mbuf.mark();\n        return '#' + mbuf.readVString();\n    } catch (e) {\n        mbuf.reset();\n        // Sender did not length-prefix the memo\n        memo = new Buffer(mbuf.toString('binary'), 'binary').toString('utf-8');\n        return '#' + memo;\n    }\n}\n\n/**\n    Some fields are only required if the memo is marked for encryption (starts with a hash).\n    @arg {string|PrivateKey} private_key - WIF or PrivateKey object\n    @arg {string|PublicKey} public_key - Recipient\n    @arg {string} memo - plain text is returned, hash prefix text is encrypted\n    @arg {string} [testNonce = undefined] - just for testing\n    @return {string} - base64 decoded string (or plain text)\n*/\nfunction encode(private_key, public_key, memo, testNonce) {\n    (0, _assert2.default)(memo, 'memo is required');\n    _assert2.default.equal(typeof memo === 'undefined' ? 'undefined' : _typeof(memo), 'string', 'memo');\n    if (!/^#/.test(memo)) return memo;\n    memo = memo.substring(1);\n\n    (0, _assert2.default)(private_key, 'private_key is required');\n    (0, _assert2.default)(public_key, 'public_key is required');\n    checkEncryption();\n\n    private_key = toPrivateObj(private_key);\n    public_key = toPublicObj(public_key);\n\n    var mbuf = new _bytebuffer2.default(_bytebuffer2.default.DEFAULT_CAPACITY, _bytebuffer2.default.LITTLE_ENDIAN);\n    mbuf.writeVString(memo);\n    memo = new Buffer(mbuf.copy(0, mbuf.offset).toBinary(), 'binary');\n\n    var _Aes$encrypt = _ecc.Aes.encrypt(private_key, public_key, memo, testNonce),\n        nonce = _Aes$encrypt.nonce,\n        message = _Aes$encrypt.message,\n        checksum = _Aes$encrypt.checksum;\n\n    memo = encMemo.fromObject({\n        from: private_key.toPublicKey(),\n        to: public_key,\n        nonce: nonce,\n        check: checksum,\n        encrypted: message\n    });\n    // serialize\n    memo = encMemo.toBuffer(memo);\n    return '#' + _bs2.default.encode(new Buffer(memo, 'binary'));\n}\n\n/** Get public keys of both sender and receiver */\nfunction getPubKeys(memo) {\n    (0, _assert2.default)(memo, 'memo is required');\n    _assert2.default.equal(typeof memo === 'undefined' ? 'undefined' : _typeof(memo), 'string', 'memo');\n    if (!/^#/.test(memo)) return [];\n    memo = memo.substring(1);\n\n    checkEncryption();\n\n    memo = _bs2.default.decode(memo);\n    memo = encMemo.fromBuffer(new Buffer(memo, 'binary'));\n\n    var _memo2 = memo,\n        from = _memo2.from,\n        to = _memo2.to;\n\n\n    return [from.toString(), to.toString()];\n}\n\nvar encodeTest = undefined;\n\n/**\n  Memo encryption has failed in the browser before.  An Error will be thrown\n  if a memo can't be encrypted and decrypted.\n*/\nfunction checkEncryption() {\n    if (encodeTest === undefined) {\n        var plaintext = void 0;\n        encodeTest = true; // prevent infinate looping\n        try {\n            var wif = '5JdeC9P7Pbd1uGdFVEsJ41EkEnADbbHGq6p1BwFxm6txNBsQnsw';\n            var pubkey = 'STM8m5UgaFAAYQRuaNejYdS8FVLVp9Ss3K1qAVk5de6F8s3HnVbvA';\n            var cyphertext = encode(wif, pubkey, '#memo爱');\n            plaintext = decode(wif, cyphertext);\n        } catch (e) {\n            console.error(e);\n        } finally {\n            encodeTest = plaintext === '#memo爱';\n        }\n    }\n    if (encodeTest === false) throw new Error('This environment does not support encryption.');\n}\n\nvar toPrivateObj = function toPrivateObj(o) {\n    return o ? o.d ? o : _ecc.PrivateKey.fromWif(o) : o /*null or undefined*/;\n};\nvar toPublicObj = function toPublicObj(o) {\n    return o ? o.Q ? o : _ecc.PublicKey.fromString(o) : o /*null or undefined*/;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}