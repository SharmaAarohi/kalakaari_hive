{"ast":null,"code":"'use strict';\n\nvar assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa\nvar crypto = require('./hash');\nvar enforceType = require('./enforce_types');\nvar BigInteger = require('bigi');\nvar ECSignature = require('./ecsignature');\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n  enforceType('Buffer', hash);\n  enforceType(BigInteger, d);\n  if (nonce) {\n    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));\n  }\n\n  // sanity check\n  assert.equal(hash.length, 32, 'Hash must be 256 bit');\n  var x = d.toBuffer(32);\n  var k = new Buffer(32);\n  var v = new Buffer(32);\n\n  // Step B\n  v.fill(1);\n\n  // Step C\n  k.fill(0);\n\n  // Step D\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);\n\n  // Step E\n  v = crypto.HmacSHA256(v, k);\n\n  // Step F\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);\n\n  // Step G\n  v = crypto.HmacSHA256(v, k);\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = crypto.HmacSHA256(v, k);\n  var T = BigInteger.fromBuffer(v);\n\n  // Step H3, repeat until T is within the interval [1, n - 1]\n  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n    v = crypto.HmacSHA256(v, k);\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = crypto.HmacSHA256(v, k);\n    T = BigInteger.fromBuffer(v);\n  }\n  return T;\n}\nfunction sign(curve, hash, d, nonce) {\n  var e = BigInteger.fromBuffer(hash);\n  var n = curve.n;\n  var G = curve.G;\n  var r, s;\n  var k = deterministicGenerateK(curve, hash, d, function (k) {\n    // find canonically valid signature\n    var Q = G.multiply(k);\n    if (curve.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }, nonce);\n  var N_OVER_TWO = n.shiftRight(1);\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n  return new ECSignature(r, s);\n}\nfunction verifyRaw(curve, e, signature, Q) {\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s;\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;\n\n  // c = s^-1 mod n\n  var c = s.modInverse(n);\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  var u1 = e.multiply(c).mod(n);\n  var u2 = r.multiply(c).mod(n);\n\n  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q\n  var R = G.multiplyTwo(u1, Q, u2);\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (curve.isInfinity(R)) return false;\n\n  // 1.4.6 Convert the field element R.x to an integer\n  var xR = R.affineX;\n\n  // 1.4.7 Set v = xR mod n\n  var v = xR.mod(n);\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.equals(r);\n}\nfunction verify(curve, hash, signature, Q) {\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  return verifyRaw(curve, e, signature, Q);\n}\n\n/**\n  * Recover a public key from a signature.\n  *\n  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n  * Key Recovery Operation\".\n  *\n  * http://www.secg.org/download/aid-780/sec1-v2.pdf\n  */\nfunction recoverPubKey(curve, e, signature, i) {\n  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s;\n  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');\n  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = curve.pointFromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.multiply(n);\n  assert(curve.isInfinity(nR), 'nR is not a valid curve point');\n\n  // Compute -e from e\n  var eNeg = e.negate().mod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  var rInv = r.modInverse(n);\n  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);\n  curve.validate(Q);\n  return Q;\n}\n\n/**\n  * Calculate pubkey extraction parameter.\n  *\n  * When extracting a pubkey from a signature, we have to\n  * distinguish four different cases. Rather than putting this\n  * burden on the verifier, Bitcoin includes a 2-bit value with the\n  * signature.\n  *\n  * This function simply tries all four cases and returns the value\n  * that resulted in a successful pubkey recovery.\n  */\nfunction calcPubKeyRecoveryParam(curve, e, signature, Q) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime = recoverPubKey(curve, e, signature, i);\n\n    // 1.6.2 Verify Q\n    if (Qprime.equals(Q)) {\n      return i;\n    }\n  }\n  throw new Error('Unable to find valid recovery factor');\n}\nmodule.exports = {\n  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,\n  deterministicGenerateK: deterministicGenerateK,\n  recoverPubKey: recoverPubKey,\n  sign: sign,\n  verify: verify,\n  verifyRaw: verifyRaw\n};","map":{"version":3,"names":["assert","require","crypto","enforceType","BigInteger","ECSignature","deterministicGenerateK","curve","hash","d","checkSig","nonce","sha256","Buffer","concat","equal","length","x","toBuffer","k","v","fill","HmacSHA256","T","fromBuffer","signum","compareTo","n","sign","e","G","r","s","Q","multiply","isInfinity","affineX","mod","modInverse","add","N_OVER_TWO","shiftRight","subtract","verifyRaw","signature","c","u1","u2","R","multiplyTwo","xR","equals","verify","recoverPubKey","i","strictEqual","isYOdd","isSecondKey","pointFromX","nR","eNeg","negate","rInv","validate","calcPubKeyRecoveryParam","Qprime","Error","module","exports"],"sources":["C:/Users/sunil/kalakaari/node_modules/@hiveio/hive-js/lib/auth/ecc/src/ecdsa.js"],"sourcesContent":["'use strict';\n\nvar assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa\nvar crypto = require('./hash');\nvar enforceType = require('./enforce_types');\n\nvar BigInteger = require('bigi');\nvar ECSignature = require('./ecsignature');\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n\n  enforceType('Buffer', hash);\n  enforceType(BigInteger, d);\n\n  if (nonce) {\n    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));\n  }\n\n  // sanity check\n  assert.equal(hash.length, 32, 'Hash must be 256 bit');\n\n  var x = d.toBuffer(32);\n  var k = new Buffer(32);\n  var v = new Buffer(32);\n\n  // Step B\n  v.fill(1);\n\n  // Step C\n  k.fill(0);\n\n  // Step D\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k);\n\n  // Step E\n  v = crypto.HmacSHA256(v, k);\n\n  // Step F\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k);\n\n  // Step G\n  v = crypto.HmacSHA256(v, k);\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = crypto.HmacSHA256(v, k);\n\n  var T = BigInteger.fromBuffer(v);\n\n  // Step H3, repeat until T is within the interval [1, n - 1]\n  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n    v = crypto.HmacSHA256(v, k);\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = crypto.HmacSHA256(v, k);\n\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nfunction sign(curve, hash, d, nonce) {\n\n  var e = BigInteger.fromBuffer(hash);\n  var n = curve.n;\n  var G = curve.G;\n\n  var r, s;\n  var k = deterministicGenerateK(curve, hash, d, function (k) {\n    // find canonically valid signature\n    var Q = G.multiply(k);\n\n    if (curve.isInfinity(Q)) return false;\n\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n\n    return true;\n  }, nonce);\n\n  var N_OVER_TWO = n.shiftRight(1);\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return new ECSignature(r, s);\n}\n\nfunction verifyRaw(curve, e, signature, Q) {\n  var n = curve.n;\n  var G = curve.G;\n\n  var r = signature.r;\n  var s = signature.s;\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false;\n\n  // c = s^-1 mod n\n  var c = s.modInverse(n);\n\n  // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n  var u1 = e.multiply(c).mod(n);\n  var u2 = r.multiply(c).mod(n);\n\n  // 1.4.5 Compute R = (xR, yR) = u1G + u2Q\n  var R = G.multiplyTwo(u1, Q, u2);\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (curve.isInfinity(R)) return false;\n\n  // 1.4.6 Convert the field element R.x to an integer\n  var xR = R.affineX;\n\n  // 1.4.7 Set v = xR mod n\n  var v = xR.mod(n);\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.equals(r);\n}\n\nfunction verify(curve, hash, signature, Q) {\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  return verifyRaw(curve, e, signature, Q);\n}\n\n/**\n  * Recover a public key from a signature.\n  *\n  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n  * Key Recovery Operation\".\n  *\n  * http://www.secg.org/download/aid-780/sec1-v2.pdf\n  */\nfunction recoverPubKey(curve, e, signature, i) {\n  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');\n\n  var n = curve.n;\n  var G = curve.G;\n\n  var r = signature.r;\n  var s = signature.s;\n\n  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');\n  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value');\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = curve.pointFromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.multiply(n);\n  assert(curve.isInfinity(nR), 'nR is not a valid curve point');\n\n  // Compute -e from e\n  var eNeg = e.negate().mod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  var rInv = r.modInverse(n);\n\n  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);\n  curve.validate(Q);\n\n  return Q;\n}\n\n/**\n  * Calculate pubkey extraction parameter.\n  *\n  * When extracting a pubkey from a signature, we have to\n  * distinguish four different cases. Rather than putting this\n  * burden on the verifier, Bitcoin includes a 2-bit value with the\n  * signature.\n  *\n  * This function simply tries all four cases and returns the value\n  * that resulted in a successful pubkey recovery.\n  */\nfunction calcPubKeyRecoveryParam(curve, e, signature, Q) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime = recoverPubKey(curve, e, signature, i);\n\n    // 1.6.2 Verify Q\n    if (Qprime.equals(Q)) {\n      return i;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n}\n\nmodule.exports = {\n  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,\n  deterministicGenerateK: deterministicGenerateK,\n  recoverPubKey: recoverPubKey,\n  sign: sign,\n  verify: verify,\n  verifyRaw: verifyRaw\n};"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;AAChC,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAC9B,IAAIE,WAAW,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAE5C,IAAIG,UAAU,GAAGH,OAAO,CAAC,MAAM,CAAC;AAChC,IAAII,WAAW,GAAGJ,OAAO,CAAC,eAAe,CAAC;;AAE1C;AACA,SAASK,sBAAsBA,CAACC,KAAK,EAAEC,IAAI,EAAEC,CAAC,EAAEC,QAAQ,EAAEC,KAAK,EAAE;EAE/DR,WAAW,CAAC,QAAQ,EAAEK,IAAI,CAAC;EAC3BL,WAAW,CAACC,UAAU,EAAEK,CAAC,CAAC;EAE1B,IAAIE,KAAK,EAAE;IACTH,IAAI,GAAGN,MAAM,CAACU,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC,CAACN,IAAI,EAAE,IAAIK,MAAM,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;EAChE;;EAEA;EACAX,MAAM,CAACe,KAAK,CAACP,IAAI,CAACQ,MAAM,EAAE,EAAE,EAAE,sBAAsB,CAAC;EAErD,IAAIC,CAAC,GAAGR,CAAC,CAACS,QAAQ,CAAC,EAAE,CAAC;EACtB,IAAIC,CAAC,GAAG,IAAIN,MAAM,CAAC,EAAE,CAAC;EACtB,IAAIO,CAAC,GAAG,IAAIP,MAAM,CAAC,EAAE,CAAC;;EAEtB;EACAO,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC;;EAET;EACAF,CAAC,CAACE,IAAI,CAAC,CAAC,CAAC;;EAET;EACAF,CAAC,GAAGjB,MAAM,CAACoB,UAAU,CAACT,MAAM,CAACC,MAAM,CAAC,CAACM,CAAC,EAAE,IAAIP,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEI,CAAC,EAAET,IAAI,CAAC,CAAC,EAAEW,CAAC,CAAC;;EAEtE;EACAC,CAAC,GAAGlB,MAAM,CAACoB,UAAU,CAACF,CAAC,EAAED,CAAC,CAAC;;EAE3B;EACAA,CAAC,GAAGjB,MAAM,CAACoB,UAAU,CAACT,MAAM,CAACC,MAAM,CAAC,CAACM,CAAC,EAAE,IAAIP,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEI,CAAC,EAAET,IAAI,CAAC,CAAC,EAAEW,CAAC,CAAC;;EAEtE;EACAC,CAAC,GAAGlB,MAAM,CAACoB,UAAU,CAACF,CAAC,EAAED,CAAC,CAAC;;EAE3B;EACA;EACAC,CAAC,GAAGlB,MAAM,CAACoB,UAAU,CAACF,CAAC,EAAED,CAAC,CAAC;EAE3B,IAAII,CAAC,GAAGnB,UAAU,CAACoB,UAAU,CAACJ,CAAC,CAAC;;EAEhC;EACA,OAAOG,CAAC,CAACE,MAAM,CAAC,CAAC,IAAI,CAAC,IAAIF,CAAC,CAACG,SAAS,CAACnB,KAAK,CAACoB,CAAC,CAAC,IAAI,CAAC,IAAI,CAACjB,QAAQ,CAACa,CAAC,CAAC,EAAE;IACnEJ,CAAC,GAAGjB,MAAM,CAACoB,UAAU,CAACT,MAAM,CAACC,MAAM,CAAC,CAACM,CAAC,EAAE,IAAIP,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEM,CAAC,CAAC;IAC7DC,CAAC,GAAGlB,MAAM,CAACoB,UAAU,CAACF,CAAC,EAAED,CAAC,CAAC;;IAE3B;IACA;IACAC,CAAC,GAAGlB,MAAM,CAACoB,UAAU,CAACF,CAAC,EAAED,CAAC,CAAC;IAE3BI,CAAC,GAAGnB,UAAU,CAACoB,UAAU,CAACJ,CAAC,CAAC;EAC9B;EAEA,OAAOG,CAAC;AACV;AAEA,SAASK,IAAIA,CAACrB,KAAK,EAAEC,IAAI,EAAEC,CAAC,EAAEE,KAAK,EAAE;EAEnC,IAAIkB,CAAC,GAAGzB,UAAU,CAACoB,UAAU,CAAChB,IAAI,CAAC;EACnC,IAAImB,CAAC,GAAGpB,KAAK,CAACoB,CAAC;EACf,IAAIG,CAAC,GAAGvB,KAAK,CAACuB,CAAC;EAEf,IAAIC,CAAC,EAAEC,CAAC;EACR,IAAIb,CAAC,GAAGb,sBAAsB,CAACC,KAAK,EAAEC,IAAI,EAAEC,CAAC,EAAE,UAAUU,CAAC,EAAE;IAC1D;IACA,IAAIc,CAAC,GAAGH,CAAC,CAACI,QAAQ,CAACf,CAAC,CAAC;IAErB,IAAIZ,KAAK,CAAC4B,UAAU,CAACF,CAAC,CAAC,EAAE,OAAO,KAAK;IAErCF,CAAC,GAAGE,CAAC,CAACG,OAAO,CAACC,GAAG,CAACV,CAAC,CAAC;IACpB,IAAII,CAAC,CAACN,MAAM,CAAC,CAAC,KAAK,CAAC,EAAE,OAAO,KAAK;IAElCO,CAAC,GAAGb,CAAC,CAACmB,UAAU,CAACX,CAAC,CAAC,CAACO,QAAQ,CAACL,CAAC,CAACU,GAAG,CAAC9B,CAAC,CAACyB,QAAQ,CAACH,CAAC,CAAC,CAAC,CAAC,CAACM,GAAG,CAACV,CAAC,CAAC;IACzD,IAAIK,CAAC,CAACP,MAAM,CAAC,CAAC,KAAK,CAAC,EAAE,OAAO,KAAK;IAElC,OAAO,IAAI;EACb,CAAC,EAAEd,KAAK,CAAC;EAET,IAAI6B,UAAU,GAAGb,CAAC,CAACc,UAAU,CAAC,CAAC,CAAC;;EAEhC;EACA,IAAIT,CAAC,CAACN,SAAS,CAACc,UAAU,CAAC,GAAG,CAAC,EAAE;IAC/BR,CAAC,GAAGL,CAAC,CAACe,QAAQ,CAACV,CAAC,CAAC;EACnB;EAEA,OAAO,IAAI3B,WAAW,CAAC0B,CAAC,EAAEC,CAAC,CAAC;AAC9B;AAEA,SAASW,SAASA,CAACpC,KAAK,EAAEsB,CAAC,EAAEe,SAAS,EAAEX,CAAC,EAAE;EACzC,IAAIN,CAAC,GAAGpB,KAAK,CAACoB,CAAC;EACf,IAAIG,CAAC,GAAGvB,KAAK,CAACuB,CAAC;EAEf,IAAIC,CAAC,GAAGa,SAAS,CAACb,CAAC;EACnB,IAAIC,CAAC,GAAGY,SAAS,CAACZ,CAAC;;EAEnB;EACA,IAAID,CAAC,CAACN,MAAM,CAAC,CAAC,IAAI,CAAC,IAAIM,CAAC,CAACL,SAAS,CAACC,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,KAAK;EACxD,IAAIK,CAAC,CAACP,MAAM,CAAC,CAAC,IAAI,CAAC,IAAIO,CAAC,CAACN,SAAS,CAACC,CAAC,CAAC,IAAI,CAAC,EAAE,OAAO,KAAK;;EAExD;EACA,IAAIkB,CAAC,GAAGb,CAAC,CAACM,UAAU,CAACX,CAAC,CAAC;;EAEvB;EACA;EACA,IAAImB,EAAE,GAAGjB,CAAC,CAACK,QAAQ,CAACW,CAAC,CAAC,CAACR,GAAG,CAACV,CAAC,CAAC;EAC7B,IAAIoB,EAAE,GAAGhB,CAAC,CAACG,QAAQ,CAACW,CAAC,CAAC,CAACR,GAAG,CAACV,CAAC,CAAC;;EAE7B;EACA,IAAIqB,CAAC,GAAGlB,CAAC,CAACmB,WAAW,CAACH,EAAE,EAAEb,CAAC,EAAEc,EAAE,CAAC;;EAEhC;EACA,IAAIxC,KAAK,CAAC4B,UAAU,CAACa,CAAC,CAAC,EAAE,OAAO,KAAK;;EAErC;EACA,IAAIE,EAAE,GAAGF,CAAC,CAACZ,OAAO;;EAElB;EACA,IAAIhB,CAAC,GAAG8B,EAAE,CAACb,GAAG,CAACV,CAAC,CAAC;;EAEjB;EACA,OAAOP,CAAC,CAAC+B,MAAM,CAACpB,CAAC,CAAC;AACpB;AAEA,SAASqB,MAAMA,CAAC7C,KAAK,EAAEC,IAAI,EAAEoC,SAAS,EAAEX,CAAC,EAAE;EACzC;EACA;EACA,IAAIJ,CAAC,GAAGzB,UAAU,CAACoB,UAAU,CAAChB,IAAI,CAAC;EACnC,OAAOmC,SAAS,CAACpC,KAAK,EAAEsB,CAAC,EAAEe,SAAS,EAAEX,CAAC,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,aAAaA,CAAC9C,KAAK,EAAEsB,CAAC,EAAEe,SAAS,EAAEU,CAAC,EAAE;EAC7CtD,MAAM,CAACuD,WAAW,CAACD,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,sCAAsC,CAAC;EAEpE,IAAI3B,CAAC,GAAGpB,KAAK,CAACoB,CAAC;EACf,IAAIG,CAAC,GAAGvB,KAAK,CAACuB,CAAC;EAEf,IAAIC,CAAC,GAAGa,SAAS,CAACb,CAAC;EACnB,IAAIC,CAAC,GAAGY,SAAS,CAACZ,CAAC;EAEnBhC,MAAM,CAAC+B,CAAC,CAACN,MAAM,CAAC,CAAC,GAAG,CAAC,IAAIM,CAAC,CAACL,SAAS,CAACC,CAAC,CAAC,GAAG,CAAC,EAAE,iBAAiB,CAAC;EAC/D3B,MAAM,CAACgC,CAAC,CAACP,MAAM,CAAC,CAAC,GAAG,CAAC,IAAIO,CAAC,CAACN,SAAS,CAACC,CAAC,CAAC,GAAG,CAAC,EAAE,iBAAiB,CAAC;;EAE/D;EACA,IAAI6B,MAAM,GAAGF,CAAC,GAAG,CAAC;;EAElB;EACA;EACA,IAAIG,WAAW,GAAGH,CAAC,IAAI,CAAC;;EAExB;EACA,IAAIrC,CAAC,GAAGwC,WAAW,GAAG1B,CAAC,CAACQ,GAAG,CAACZ,CAAC,CAAC,GAAGI,CAAC;EAClC,IAAIiB,CAAC,GAAGzC,KAAK,CAACmD,UAAU,CAACF,MAAM,EAAEvC,CAAC,CAAC;;EAEnC;EACA,IAAI0C,EAAE,GAAGX,CAAC,CAACd,QAAQ,CAACP,CAAC,CAAC;EACtB3B,MAAM,CAACO,KAAK,CAAC4B,UAAU,CAACwB,EAAE,CAAC,EAAE,+BAA+B,CAAC;;EAE7D;EACA,IAAIC,IAAI,GAAG/B,CAAC,CAACgC,MAAM,CAAC,CAAC,CAACxB,GAAG,CAACV,CAAC,CAAC;;EAE5B;EACA;EACA,IAAImC,IAAI,GAAG/B,CAAC,CAACO,UAAU,CAACX,CAAC,CAAC;EAE1B,IAAIM,CAAC,GAAGe,CAAC,CAACC,WAAW,CAACjB,CAAC,EAAEF,CAAC,EAAE8B,IAAI,CAAC,CAAC1B,QAAQ,CAAC4B,IAAI,CAAC;EAChDvD,KAAK,CAACwD,QAAQ,CAAC9B,CAAC,CAAC;EAEjB,OAAOA,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+B,uBAAuBA,CAACzD,KAAK,EAAEsB,CAAC,EAAEe,SAAS,EAAEX,CAAC,EAAE;EACvD,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1B,IAAIW,MAAM,GAAGZ,aAAa,CAAC9C,KAAK,EAAEsB,CAAC,EAAEe,SAAS,EAAEU,CAAC,CAAC;;IAElD;IACA,IAAIW,MAAM,CAACd,MAAM,CAAClB,CAAC,CAAC,EAAE;MACpB,OAAOqB,CAAC;IACV;EACF;EAEA,MAAM,IAAIY,KAAK,CAAC,sCAAsC,CAAC;AACzD;AAEAC,MAAM,CAACC,OAAO,GAAG;EACfJ,uBAAuB,EAAEA,uBAAuB;EAChD1D,sBAAsB,EAAEA,sBAAsB;EAC9C+C,aAAa,EAAEA,aAAa;EAC5BzB,IAAI,EAAEA,IAAI;EACVwB,MAAM,EAAEA,MAAM;EACdT,SAAS,EAAEA;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}