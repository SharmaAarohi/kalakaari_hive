{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ecurve = require('ecurve');\nvar Point = ecurve.Point;\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\nvar BigInteger = require('bigi');\nvar base58 = require('bs58');\nvar assert = require('assert');\nvar hash = require('./hash');\nvar PublicKey = require('./key_public');\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nvar PrivateKey = function () {\n  /**\n      @private see static functions\n      @param {BigInteger}\n  */\n  function PrivateKey(d) {\n    _classCallCheck(this, PrivateKey);\n    this.d = d;\n  }\n  _createClass(PrivateKey, [{\n    key: 'toWif',\n    value: function toWif() {\n      var private_key = this.toBuffer();\n      // checksum includes the version\n      private_key = Buffer.concat([new Buffer([0x80]), private_key]);\n      var checksum = hash.sha256(private_key);\n      checksum = hash.sha256(checksum);\n      checksum = checksum.slice(0, 4);\n      var private_wif = Buffer.concat([private_key, checksum]);\n      return base58.encode(private_wif);\n    }\n\n    /** Alias for {@link toWif} */\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.toWif();\n    }\n\n    /**\n        @return {Point}\n    */\n  }, {\n    key: 'toPublicKeyPoint',\n    value: function toPublicKeyPoint() {\n      var Q;\n      return Q = secp256k1.G.multiply(this.d);\n    }\n  }, {\n    key: 'toPublic',\n    value: function toPublic() {\n      if (this.public_key) {\n        return this.public_key;\n      }\n      return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());\n    }\n  }, {\n    key: 'toBuffer',\n    value: function toBuffer() {\n      return this.d.toBuffer(32);\n    }\n\n    /** ECIES */\n  }, {\n    key: 'get_shared_secret',\n    value: function get_shared_secret(public_key) {\n      public_key = toPublic(public_key);\n      var KB = public_key.toUncompressed().toBuffer();\n      var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)),\n      // x\n      BigInteger.fromBuffer(KB.slice(33, 65)) // y\n      );\n      var r = this.toBuffer();\n      var P = KBP.multiply(BigInteger.fromBuffer(r));\n      var S = P.affineX.toBuffer({\n        size: 32\n      });\n      // SHA512 used in ECIES\n      return hash.sha512(S);\n    }\n\n    // /** ECIES (does not always match the Point.fromAffine version above) */\n    // get_shared_secret(public_key){\n    //     public_key = toPublic(public_key)\n    //     var P = public_key.Q.multiply( this.d );\n    //     var S = P.affineX.toBuffer({size: 32});\n    //     // ECIES, adds an extra sha512\n    //     return hash.sha512(S);\n    // }\n\n    /** @throws {Error} - overflow of the key could not be derived */\n  }, {\n    key: 'child',\n    value: function child(offset) {\n      offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);\n      offset = hash.sha256(offset);\n      var c = BigInteger.fromBuffer(offset);\n      if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n      var derived = this.d.add(c); //.mod(n)\n\n      if (derived.signum() === 0) throw new Error(\"Child offset derived to an invalid key, try again\");\n      return new PrivateKey(derived);\n    }\n\n    // toByteBuffer() {\n    //     var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n    //     this.appendByteBuffer(b);\n    //     return b.copy(0, b.offset);\n    // }\n  }, {\n    key: 'toHex',\n    value: function toHex() {\n      return this.toBuffer().toString('hex');\n    }\n  }, {\n    key: 'toPublicKey',\n    value: function toPublicKey() {\n      return this.toPublic();\n    }\n\n    /* </helper_functions> */\n  }], [{\n    key: 'fromBuffer',\n    value: function fromBuffer(buf) {\n      if (!Buffer.isBuffer(buf)) {\n        throw new Error(\"Expecting paramter to be a Buffer type\");\n      }\n      if (32 !== buf.length) {\n        console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);\n      }\n      if (buf.length === 0) {\n        throw new Error(\"Empty buffer\");\n      }\n      return new PrivateKey(BigInteger.fromBuffer(buf));\n    }\n\n    /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */\n  }, {\n    key: 'fromSeed',\n    value: function fromSeed(seed) {\n      // generate_private_key\n      if (!(typeof seed === 'string')) {\n        throw new Error('seed must be of type string');\n      }\n      return PrivateKey.fromBuffer(hash.sha256(seed));\n    }\n  }, {\n    key: 'isWif',\n    value: function isWif(text) {\n      try {\n        this.fromWif(text);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    /**\n        @throws {AssertError|Error} parsing key\n        @return {string} Wallet Import Format (still a secret, Not encrypted)\n    */\n  }, {\n    key: 'fromWif',\n    value: function fromWif(_private_wif) {\n      var private_wif = new Buffer(base58.decode(_private_wif));\n      var version = private_wif.readUInt8(0);\n      assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);\n      // checksum includes the version\n      var private_key = private_wif.slice(0, -4);\n      var checksum = private_wif.slice(-4);\n      var new_checksum = hash.sha256(private_key);\n      new_checksum = hash.sha256(new_checksum);\n      new_checksum = new_checksum.slice(0, 4);\n      if (checksum.toString() !== new_checksum.toString()) throw new Error('Invalid WIF key (checksum miss-match)');\n      private_key = private_key.slice(1);\n      return PrivateKey.fromBuffer(private_key);\n    }\n  }, {\n    key: 'fromHex',\n    value: function fromHex(hex) {\n      return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));\n    }\n  }]);\n  return PrivateKey;\n}();\nmodule.exports = PrivateKey;\nvar toPublic = function toPublic(data) {\n  return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);\n};","map":{"version":3,"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","ecurve","require","Point","secp256k1","getCurveByName","BigInteger","base58","assert","hash","PublicKey","G","n","PrivateKey","d","value","toWif","private_key","toBuffer","Buffer","concat","checksum","sha256","slice","private_wif","encode","toString","toPublicKeyPoint","Q","multiply","toPublic","public_key","fromPoint","get_shared_secret","KB","toUncompressed","KBP","fromAffine","fromBuffer","r","P","S","affineX","size","sha512","child","offset","toPublicKey","c","compareTo","Error","derived","add","signum","toHex","buf","isBuffer","console","log","stack","fromSeed","seed","isWif","text","fromWif","e","_private_wif","decode","version","readUInt8","equal","new_checksum","fromHex","hex","module","exports","data","fromStringOrThrow"],"sources":["C:/Users/sunil/kalakaari/node_modules/@hiveio/hive-js/lib/auth/ecc/src/key_private.js"],"sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ecurve = require('ecurve');\nvar Point = ecurve.Point;\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\nvar BigInteger = require('bigi');\nvar base58 = require('bs58');\nvar assert = require('assert');\nvar hash = require('./hash');\nvar PublicKey = require('./key_public');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\n\nvar PrivateKey = function () {\n\n    /**\n        @private see static functions\n        @param {BigInteger}\n    */\n    function PrivateKey(d) {\n        _classCallCheck(this, PrivateKey);\n\n        this.d = d;\n    }\n\n    _createClass(PrivateKey, [{\n        key: 'toWif',\n        value: function toWif() {\n            var private_key = this.toBuffer();\n            // checksum includes the version\n            private_key = Buffer.concat([new Buffer([0x80]), private_key]);\n            var checksum = hash.sha256(private_key);\n            checksum = hash.sha256(checksum);\n            checksum = checksum.slice(0, 4);\n            var private_wif = Buffer.concat([private_key, checksum]);\n            return base58.encode(private_wif);\n        }\n\n        /** Alias for {@link toWif} */\n\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return this.toWif();\n        }\n\n        /**\n            @return {Point}\n        */\n\n    }, {\n        key: 'toPublicKeyPoint',\n        value: function toPublicKeyPoint() {\n            var Q;\n            return Q = secp256k1.G.multiply(this.d);\n        }\n    }, {\n        key: 'toPublic',\n        value: function toPublic() {\n            if (this.public_key) {\n                return this.public_key;\n            }\n            return this.public_key = PublicKey.fromPoint(this.toPublicKeyPoint());\n        }\n    }, {\n        key: 'toBuffer',\n        value: function toBuffer() {\n            return this.d.toBuffer(32);\n        }\n\n        /** ECIES */\n\n    }, {\n        key: 'get_shared_secret',\n        value: function get_shared_secret(public_key) {\n            public_key = toPublic(public_key);\n            var KB = public_key.toUncompressed().toBuffer();\n            var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x\n            BigInteger.fromBuffer(KB.slice(33, 65)) // y\n            );\n            var r = this.toBuffer();\n            var P = KBP.multiply(BigInteger.fromBuffer(r));\n            var S = P.affineX.toBuffer({ size: 32 });\n            // SHA512 used in ECIES\n            return hash.sha512(S);\n        }\n\n        // /** ECIES (does not always match the Point.fromAffine version above) */\n        // get_shared_secret(public_key){\n        //     public_key = toPublic(public_key)\n        //     var P = public_key.Q.multiply( this.d );\n        //     var S = P.affineX.toBuffer({size: 32});\n        //     // ECIES, adds an extra sha512\n        //     return hash.sha512(S);\n        // }\n\n        /** @throws {Error} - overflow of the key could not be derived */\n\n    }, {\n        key: 'child',\n        value: function child(offset) {\n            offset = Buffer.concat([this.toPublicKey().toBuffer(), offset]);\n            offset = hash.sha256(offset);\n            var c = BigInteger.fromBuffer(offset);\n\n            if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n\n            var derived = this.d.add(c); //.mod(n)\n\n            if (derived.signum() === 0) throw new Error(\"Child offset derived to an invalid key, try again\");\n\n            return new PrivateKey(derived);\n        }\n\n        // toByteBuffer() {\n        //     var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n        //     this.appendByteBuffer(b);\n        //     return b.copy(0, b.offset);\n        // }\n\n    }, {\n        key: 'toHex',\n        value: function toHex() {\n            return this.toBuffer().toString('hex');\n        }\n    }, {\n        key: 'toPublicKey',\n        value: function toPublicKey() {\n            return this.toPublic();\n        }\n\n        /* </helper_functions> */\n\n    }], [{\n        key: 'fromBuffer',\n        value: function fromBuffer(buf) {\n            if (!Buffer.isBuffer(buf)) {\n                throw new Error(\"Expecting paramter to be a Buffer type\");\n            }\n            if (32 !== buf.length) {\n                console.log('WARN: Expecting 32 bytes, instead got ' + buf.length + ', stack trace:', new Error().stack);\n            }\n            if (buf.length === 0) {\n                throw new Error(\"Empty buffer\");\n            }\n            return new PrivateKey(BigInteger.fromBuffer(buf));\n        }\n\n        /** @arg {string} seed - any length string.  This is private, the same seed produces the same private key every time.  */\n\n    }, {\n        key: 'fromSeed',\n        value: function fromSeed(seed) {\n            // generate_private_key\n            if (!(typeof seed === 'string')) {\n                throw new Error('seed must be of type string');\n            }\n            return PrivateKey.fromBuffer(hash.sha256(seed));\n        }\n    }, {\n        key: 'isWif',\n        value: function isWif(text) {\n            try {\n                this.fromWif(text);\n                return true;\n            } catch (e) {\n                return false;\n            }\n        }\n\n        /**\n            @throws {AssertError|Error} parsing key\n            @return {string} Wallet Import Format (still a secret, Not encrypted)\n        */\n\n    }, {\n        key: 'fromWif',\n        value: function fromWif(_private_wif) {\n            var private_wif = new Buffer(base58.decode(_private_wif));\n            var version = private_wif.readUInt8(0);\n            assert.equal(0x80, version, 'Expected version ' + 0x80 + ', instead got ' + version);\n            // checksum includes the version\n            var private_key = private_wif.slice(0, -4);\n            var checksum = private_wif.slice(-4);\n            var new_checksum = hash.sha256(private_key);\n            new_checksum = hash.sha256(new_checksum);\n            new_checksum = new_checksum.slice(0, 4);\n            if (checksum.toString() !== new_checksum.toString()) throw new Error('Invalid WIF key (checksum miss-match)');\n\n            private_key = private_key.slice(1);\n            return PrivateKey.fromBuffer(private_key);\n        }\n    }, {\n        key: 'fromHex',\n        value: function fromHex(hex) {\n            return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));\n        }\n    }]);\n\n    return PrivateKey;\n}();\n\nmodule.exports = PrivateKey;\n\nvar toPublic = function toPublic(data) {\n    return data == null ? data : data.Q ? data : PublicKey.fromStringOrThrow(data);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}