{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nexports.toImpliedDecimal = toImpliedDecimal;\nexports.fromImpliedDecimal = fromImpliedDecimal;\nvar _assert = require(\"assert\");\nvar _assert2 = _interopRequireDefault(_assert);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n    Convert 12.34 with a precision of 3 into 12340\n\n    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign\n    @arg {number} precision - number of implied decimal places (usually causes right zero padding)\n    @return {string} -\n*/\nfunction toImpliedDecimal(number, precision) {\n  if (typeof number === \"number\") {\n    (0, _assert2.default)(number <= 9007199254740991, \"overflow\");\n    number = \"\" + number;\n  } else if (number.toString) number = number.toString();\n  (0, _assert2.default)(typeof number === \"string\", \"number should be an actual number or string: \" + (typeof number === \"undefined\" ? \"undefined\" : _typeof(number)));\n  number = number.trim();\n  (0, _assert2.default)(/^[0-9]*\\.?[0-9]*$/.test(number), \"Invalid decimal number \" + number);\n  var _number$split = number.split(\".\"),\n    _number$split2 = _slicedToArray(_number$split, 2),\n    _number$split2$ = _number$split2[0],\n    whole = _number$split2$ === undefined ? \"\" : _number$split2$,\n    _number$split2$2 = _number$split2[1],\n    decimal = _number$split2$2 === undefined ? \"\" : _number$split2$2;\n  var padding = precision - decimal.length;\n  (0, _assert2.default)(padding >= 0, \"Too many decimal digits in \" + number + \" to create an implied decimal of \" + precision);\n  for (var i = 0; i < padding; i++) {\n    decimal += \"0\";\n  }\n  while (whole.charAt(0) === \"0\") {\n    whole = whole.substring(1);\n  }\n  return whole + decimal;\n}\nfunction fromImpliedDecimal(number, precision) {\n  if (typeof number === \"number\") {\n    (0, _assert2.default)(number <= 9007199254740991, \"overflow\");\n    number = \"\" + number;\n  } else if (number.toString) number = number.toString();\n  while (number.length < precision + 1) {\n    // 0.123\n    number = \"0\" + number;\n  } // 44000 => 44.000\n  var dec_string = number.substring(number.length - precision);\n  return number.substring(0, number.length - precision) + (dec_string ? \".\" + dec_string : \"\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_typeof","obj","constructor","prototype","toImpliedDecimal","fromImpliedDecimal","_assert","require","_assert2","_interopRequireDefault","__esModule","default","number","precision","toString","trim","test","_number$split","split","_number$split2","_number$split2$","whole","_number$split2$2","decimal","padding","charAt","substring","dec_string"],"sources":["C:/Users/sunil/kalakaari/node_modules/@hiveio/hive-js/lib/auth/serializer/src/number_utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.toImpliedDecimal = toImpliedDecimal;\nexports.fromImpliedDecimal = fromImpliedDecimal;\n\nvar _assert = require(\"assert\");\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n    Convert 12.34 with a precision of 3 into 12340\n\n    @arg {number|string} number - Use strings for large numbers.  This may contain one decimal but no sign\n    @arg {number} precision - number of implied decimal places (usually causes right zero padding)\n    @return {string} -\n*/\nfunction toImpliedDecimal(number, precision) {\n\n    if (typeof number === \"number\") {\n        (0, _assert2.default)(number <= 9007199254740991, \"overflow\");\n        number = \"\" + number;\n    } else if (number.toString) number = number.toString();\n\n    (0, _assert2.default)(typeof number === \"string\", \"number should be an actual number or string: \" + (typeof number === \"undefined\" ? \"undefined\" : _typeof(number)));\n    number = number.trim();\n    (0, _assert2.default)(/^[0-9]*\\.?[0-9]*$/.test(number), \"Invalid decimal number \" + number);\n\n    var _number$split = number.split(\".\"),\n        _number$split2 = _slicedToArray(_number$split, 2),\n        _number$split2$ = _number$split2[0],\n        whole = _number$split2$ === undefined ? \"\" : _number$split2$,\n        _number$split2$2 = _number$split2[1],\n        decimal = _number$split2$2 === undefined ? \"\" : _number$split2$2;\n\n    var padding = precision - decimal.length;\n    (0, _assert2.default)(padding >= 0, \"Too many decimal digits in \" + number + \" to create an implied decimal of \" + precision);\n\n    for (var i = 0; i < padding; i++) {\n        decimal += \"0\";\n    }while (whole.charAt(0) === \"0\") {\n        whole = whole.substring(1);\n    }return whole + decimal;\n}\n\nfunction fromImpliedDecimal(number, precision) {\n    if (typeof number === \"number\") {\n        (0, _assert2.default)(number <= 9007199254740991, \"overflow\");\n        number = \"\" + number;\n    } else if (number.toString) number = number.toString();\n\n    while (number.length < precision + 1) {\n        // 0.123\n        number = \"0\" + number;\n    } // 44000 => 44.000\n    var dec_string = number.substring(number.length - precision);\n    return number.substring(0, number.length - precision) + (dec_string ? \".\" + dec_string : \"\");\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}