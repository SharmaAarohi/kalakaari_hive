{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar BigInteger = require('bigi');\nvar ecurve = require('ecurve');\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\nBigInteger = require('bigi');\nvar base58 = require('bs58');\nvar hash = require('./hash');\nvar config = require('../../../config');\nvar assert = require('assert');\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nvar PublicKey = function () {\n  /** @param {ecurve.Point} public key */\n  function PublicKey(Q) {\n    _classCallCheck(this, PublicKey);\n    this.Q = Q;\n  }\n  _createClass(PublicKey, [{\n    key: 'toBuffer',\n    value: function toBuffer() {\n      var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;\n      if (this.Q === null) return Buffer.from(\"000000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n      return this.Q.getEncoded(compressed);\n    }\n  }, {\n    key: 'toUncompressed',\n    value: function toUncompressed() {\n      var buf = this.Q.getEncoded(false);\n      var point = ecurve.Point.decodeFrom(secp256k1, buf);\n      return PublicKey.fromPoint(point);\n    }\n\n    /** bts::blockchain::address (unique but not a full public key) */\n  }, {\n    key: 'toBlockchainAddress',\n    value: function toBlockchainAddress() {\n      var pub_buf = this.toBuffer();\n      var pub_sha = hash.sha512(pub_buf);\n      return hash.ripemd160(pub_sha);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');\n      return this.toPublicKeyString(address_prefix);\n    }\n\n    /**\n        Full public key\n        {return} string\n    */\n  }, {\n    key: 'toPublicKeyString',\n    value: function toPublicKeyString() {\n      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');\n      if (this.pubdata) return address_prefix + this.pubdata;\n      var pub_buf = this.toBuffer();\n      var checksum = hash.ripemd160(pub_buf);\n      var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);\n      this.pubdata = base58.encode(addy);\n      return address_prefix + this.pubdata;\n    }\n\n    /**\n        @arg {string} public_key - like STMXyz...\n        @arg {string} address_prefix - like STM\n        @return PublicKey or `null` (if the public_key string is invalid)\n        @deprecated fromPublicKeyString (use fromString instead)\n    */\n  }, {\n    key: 'toAddressString',\n    value: function toAddressString() {\n      var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');\n      var pub_buf = this.toBuffer();\n      var pub_sha = hash.sha512(pub_buf);\n      var addy = hash.ripemd160(pub_sha);\n      var checksum = hash.ripemd160(addy);\n      addy = Buffer.concat([addy, checksum.slice(0, 4)]);\n      return address_prefix + base58.encode(addy);\n    }\n  }, {\n    key: 'toPtsAddy',\n    value: function toPtsAddy() {\n      var pub_buf = this.toBuffer();\n      var pub_sha = hash.sha256(pub_buf);\n      var addy = hash.ripemd160(pub_sha);\n      addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)\n\n      var checksum = hash.sha256(addy);\n      checksum = hash.sha256(checksum);\n      addy = Buffer.concat([addy, checksum.slice(0, 4)]);\n      return base58.encode(addy);\n    }\n  }, {\n    key: 'child',\n    value: function child(offset) {\n      assert(Buffer.isBuffer(offset), \"Buffer required: offset\");\n      assert.equal(offset.length, 32, \"offset length\");\n      offset = Buffer.concat([this.toBuffer(), offset]);\n      offset = hash.sha256(offset);\n      var c = BigInteger.fromBuffer(offset);\n      if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n      var cG = G.multiply(c);\n      var Qprime = this.Q.add(cG);\n      if (secp256k1.isInfinity(Qprime)) throw new Error(\"Child offset derived to an invalid key, try again\");\n      return PublicKey.fromPoint(Qprime);\n    }\n\n    // toByteBuffer() {\n    //     var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n    //     this.appendByteBuffer(b);\n    //     return b.copy(0, b.offset);\n    // }\n  }, {\n    key: 'toHex',\n    value: function toHex() {\n      return this.toBuffer().toString('hex');\n    }\n  }], [{\n    key: 'fromBinary',\n    value: function fromBinary(bin) {\n      return PublicKey.fromBuffer(new Buffer(bin, 'binary'));\n    }\n  }, {\n    key: 'fromBuffer',\n    value: function fromBuffer(buffer) {\n      if (buffer.toString(\"hex\") === \"000000000000000000000000000000000000000000000000000000000000000000\") return new PublicKey(null);\n      return new PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));\n    }\n  }, {\n    key: 'fromPoint',\n    value: function fromPoint(point) {\n      return new PublicKey(point);\n    }\n  }, {\n    key: 'fromString',\n    value: function fromString(public_key) {\n      var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');\n      try {\n        return PublicKey.fromStringOrThrow(public_key, address_prefix);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    /**\n        @arg {string} public_key - like STMXyz...\n        @arg {string} address_prefix - like STM\n        @throws {Error} if public key is invalid\n        @return PublicKey\n    */\n  }, {\n    key: 'fromStringOrThrow',\n    value: function fromStringOrThrow(public_key) {\n      var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');\n      var prefix = public_key.slice(0, address_prefix.length);\n      assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);\n      public_key = public_key.slice(address_prefix.length);\n      public_key = new Buffer(base58.decode(public_key), 'binary');\n      var checksum = public_key.slice(-4);\n      public_key = public_key.slice(0, -4);\n      var new_checksum = hash.ripemd160(public_key);\n      new_checksum = new_checksum.slice(0, 4);\n      assert.deepEqual(checksum, new_checksum, 'Checksum did not match');\n      return PublicKey.fromBuffer(public_key);\n    }\n  }, {\n    key: 'fromHex',\n    value: function fromHex(hex) {\n      return PublicKey.fromBuffer(new Buffer(hex, 'hex'));\n    }\n  }, {\n    key: 'fromStringHex',\n    value: function fromStringHex(hex) {\n      return PublicKey.fromString(new Buffer(hex, 'hex'));\n    }\n\n    /* </HEX> */\n  }]);\n  return PublicKey;\n}();\nmodule.exports = PublicKey;","map":{"version":3,"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","BigInteger","require","ecurve","secp256k1","getCurveByName","base58","hash","config","assert","G","n","PublicKey","Q","value","toBuffer","compressed","arguments","undefined","Buffer","from","getEncoded","toUncompressed","buf","point","Point","decodeFrom","fromPoint","toBlockchainAddress","pub_buf","pub_sha","sha512","ripemd160","toString","address_prefix","get","toPublicKeyString","pubdata","checksum","addy","concat","slice","encode","toAddressString","toPtsAddy","sha256","child","offset","isBuffer","equal","c","fromBuffer","compareTo","Error","cG","multiply","Qprime","add","isInfinity","toHex","fromBinary","bin","buffer","fromString","public_key","fromStringOrThrow","e","prefix","decode","new_checksum","deepEqual","fromHex","hex","fromStringHex","module","exports"],"sources":["C:/Users/sunil/kalakaari/node_modules/@hiveio/hive-js/lib/auth/ecc/src/key_public.js"],"sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BigInteger = require('bigi');\nvar ecurve = require('ecurve');\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\nBigInteger = require('bigi');\nvar base58 = require('bs58');\nvar hash = require('./hash');\nvar config = require('../../../config');\nvar assert = require('assert');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\n\nvar PublicKey = function () {\n\n    /** @param {ecurve.Point} public key */\n    function PublicKey(Q) {\n        _classCallCheck(this, PublicKey);\n\n        this.Q = Q;\n    }\n\n    _createClass(PublicKey, [{\n        key: 'toBuffer',\n        value: function toBuffer() {\n            var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.Q ? this.Q.compressed : null;\n\n            if (this.Q === null) return Buffer.from(\"000000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n            return this.Q.getEncoded(compressed);\n        }\n    }, {\n        key: 'toUncompressed',\n        value: function toUncompressed() {\n            var buf = this.Q.getEncoded(false);\n            var point = ecurve.Point.decodeFrom(secp256k1, buf);\n            return PublicKey.fromPoint(point);\n        }\n\n        /** bts::blockchain::address (unique but not a full public key) */\n\n    }, {\n        key: 'toBlockchainAddress',\n        value: function toBlockchainAddress() {\n            var pub_buf = this.toBuffer();\n            var pub_sha = hash.sha512(pub_buf);\n            return hash.ripemd160(pub_sha);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');\n\n            return this.toPublicKeyString(address_prefix);\n        }\n\n        /**\n            Full public key\n            {return} string\n        */\n\n    }, {\n        key: 'toPublicKeyString',\n        value: function toPublicKeyString() {\n            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');\n\n            if (this.pubdata) return address_prefix + this.pubdata;\n            var pub_buf = this.toBuffer();\n            var checksum = hash.ripemd160(pub_buf);\n            var addy = Buffer.concat([pub_buf, checksum.slice(0, 4)]);\n            this.pubdata = base58.encode(addy);\n            return address_prefix + this.pubdata;\n        }\n\n        /**\n            @arg {string} public_key - like STMXyz...\n            @arg {string} address_prefix - like STM\n            @return PublicKey or `null` (if the public_key string is invalid)\n            @deprecated fromPublicKeyString (use fromString instead)\n        */\n\n    }, {\n        key: 'toAddressString',\n        value: function toAddressString() {\n            var address_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get('address_prefix');\n\n            var pub_buf = this.toBuffer();\n            var pub_sha = hash.sha512(pub_buf);\n            var addy = hash.ripemd160(pub_sha);\n            var checksum = hash.ripemd160(addy);\n            addy = Buffer.concat([addy, checksum.slice(0, 4)]);\n            return address_prefix + base58.encode(addy);\n        }\n    }, {\n        key: 'toPtsAddy',\n        value: function toPtsAddy() {\n            var pub_buf = this.toBuffer();\n            var pub_sha = hash.sha256(pub_buf);\n            var addy = hash.ripemd160(pub_sha);\n            addy = Buffer.concat([new Buffer([0x38]), addy]); //version 56(decimal)\n\n            var checksum = hash.sha256(addy);\n            checksum = hash.sha256(checksum);\n\n            addy = Buffer.concat([addy, checksum.slice(0, 4)]);\n            return base58.encode(addy);\n        }\n    }, {\n        key: 'child',\n        value: function child(offset) {\n\n            assert(Buffer.isBuffer(offset), \"Buffer required: offset\");\n            assert.equal(offset.length, 32, \"offset length\");\n\n            offset = Buffer.concat([this.toBuffer(), offset]);\n            offset = hash.sha256(offset);\n\n            var c = BigInteger.fromBuffer(offset);\n\n            if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n\n            var cG = G.multiply(c);\n            var Qprime = this.Q.add(cG);\n\n            if (secp256k1.isInfinity(Qprime)) throw new Error(\"Child offset derived to an invalid key, try again\");\n\n            return PublicKey.fromPoint(Qprime);\n        }\n\n        // toByteBuffer() {\n        //     var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n        //     this.appendByteBuffer(b);\n        //     return b.copy(0, b.offset);\n        // }\n\n    }, {\n        key: 'toHex',\n        value: function toHex() {\n            return this.toBuffer().toString('hex');\n        }\n    }], [{\n        key: 'fromBinary',\n        value: function fromBinary(bin) {\n            return PublicKey.fromBuffer(new Buffer(bin, 'binary'));\n        }\n    }, {\n        key: 'fromBuffer',\n        value: function fromBuffer(buffer) {\n            if (buffer.toString(\"hex\") === \"000000000000000000000000000000000000000000000000000000000000000000\") return new PublicKey(null);\n            return new PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));\n        }\n    }, {\n        key: 'fromPoint',\n        value: function fromPoint(point) {\n            return new PublicKey(point);\n        }\n    }, {\n        key: 'fromString',\n        value: function fromString(public_key) {\n            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');\n\n            try {\n                return PublicKey.fromStringOrThrow(public_key, address_prefix);\n            } catch (e) {\n                return null;\n            }\n        }\n\n        /**\n            @arg {string} public_key - like STMXyz...\n            @arg {string} address_prefix - like STM\n            @throws {Error} if public key is invalid\n            @return PublicKey\n        */\n\n    }, {\n        key: 'fromStringOrThrow',\n        value: function fromStringOrThrow(public_key) {\n            var address_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : config.get('address_prefix');\n\n            var prefix = public_key.slice(0, address_prefix.length);\n            assert.equal(address_prefix, prefix, 'Expecting key to begin with ' + address_prefix + ', instead got ' + prefix);\n            public_key = public_key.slice(address_prefix.length);\n\n            public_key = new Buffer(base58.decode(public_key), 'binary');\n            var checksum = public_key.slice(-4);\n            public_key = public_key.slice(0, -4);\n            var new_checksum = hash.ripemd160(public_key);\n            new_checksum = new_checksum.slice(0, 4);\n            assert.deepEqual(checksum, new_checksum, 'Checksum did not match');\n            return PublicKey.fromBuffer(public_key);\n        }\n    }, {\n        key: 'fromHex',\n        value: function fromHex(hex) {\n            return PublicKey.fromBuffer(new Buffer(hex, 'hex'));\n        }\n    }, {\n        key: 'fromStringHex',\n        value: function fromStringHex(hex) {\n            return PublicKey.fromString(new Buffer(hex, 'hex'));\n        }\n\n        /* </HEX> */\n\n    }]);\n\n    return PublicKey;\n}();\n\nmodule.exports = PublicKey;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}