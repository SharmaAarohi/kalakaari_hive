{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nvar ByteBuffer = require('bytebuffer');\nvar EC = require('./error_with_cause');\nvar HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;\nvar Serializer = function () {\n  function Serializer(operation_name, types) {\n    _classCallCheck(this, Serializer);\n    this.operation_name = operation_name;\n    this.types = types;\n    if (this.types) this.keys = Object.keys(this.types);\n    Serializer.printDebug = true;\n  }\n  _createClass(Serializer, [{\n    key: 'fromByteBuffer',\n    value: function fromByteBuffer(b) {\n      var object = {};\n      var field = null;\n      try {\n        var iterable = this.keys;\n        for (var i = 0, field; i < iterable.length; i++) {\n          field = iterable[i];\n          var type = this.types[field];\n          try {\n            if (HEX_DUMP) {\n              if (type.operation_name) {\n                console.error(type.operation_name);\n              } else {\n                var o1 = b.offset;\n                type.fromByteBuffer(b);\n                var o2 = b.offset;\n                b.offset = o1;\n                //b.reset()\n                var _b = b.copy(o1, o2);\n                console.error(this.operation_name + '.' + field + '\\t', _b.toHex());\n              }\n            }\n            object[field] = type.fromByteBuffer(b);\n          } catch (e) {\n            if (Serializer.printDebug) {\n              console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');\n              b.printDebug();\n            }\n            throw e;\n          }\n        }\n      } catch (error) {\n        EC.throw(this.operation_name + '.' + field, error);\n      }\n      return object;\n    }\n  }, {\n    key: 'appendByteBuffer',\n    value: function appendByteBuffer(b, object) {\n      var field = null;\n      try {\n        var iterable = this.keys;\n        for (var i = 0, field; i < iterable.length; i++) {\n          field = iterable[i];\n          var type = this.types[field];\n          type.appendByteBuffer(b, object[field]);\n        }\n      } catch (error) {\n        try {\n          EC.throw(this.operation_name + '.' + field + \" = \" + JSON.stringify(object[field]), error);\n        } catch (e) {\n          // circular ref\n          EC.throw(this.operation_name + '.' + field + \" = \" + object[field], error);\n        }\n      }\n      return;\n    }\n  }, {\n    key: 'fromObject',\n    value: function fromObject(serialized_object) {\n      var result = {};\n      var field = null;\n      try {\n        var iterable = this.keys;\n        for (var i = 0, field; i < iterable.length; i++) {\n          field = iterable[i];\n          var type = this.types[field];\n          var value = serialized_object[field];\n          //DEBUG value = value.resolve if value.resolve\n          //DEBUG console.log('... value',field,value)\n          var object = type.fromObject(value);\n          result[field] = object;\n        }\n      } catch (error) {\n        EC.throw(this.operation_name + '.' + field, error);\n      }\n      return result;\n    }\n\n    /**\n        @arg {boolean} [debug.use_default = false] - more template friendly\n        @arg {boolean} [debug.annotate = false] - add user-friendly information\n    */\n  }, {\n    key: 'toObject',\n    value: function toObject() {\n      var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        use_default: false,\n        annotate: false\n      };\n      var result = {};\n      var field = null;\n      try {\n        if (!this.types) return result;\n        var iterable = this.keys;\n        for (var i = 0, field; i < iterable.length; i++) {\n          field = iterable[i];\n          var type = this.types[field];\n          var object = type.toObject(typeof serialized_object !== \"undefined\" && serialized_object !== null ? serialized_object[field] : undefined, debug);\n          result[field] = object;\n          if (HEX_DUMP) {\n            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n            var has_value = typeof serialized_object !== \"undefined\" && serialized_object !== null;\n            if (has_value) {\n              var value = serialized_object[field];\n              if (value) type.appendByteBuffer(b, value);\n            }\n            b = b.copy(0, b.offset);\n            console.error(this.operation_name + '.' + field, b.toHex());\n          }\n        }\n      } catch (error) {\n        EC.throw(this.operation_name + '.' + field, error);\n      }\n      return result;\n    }\n\n    /** Sort by the first element in a operation */\n  }, {\n    key: 'compare',\n    value: function compare(a, b) {\n      var first_key = this.keys[0];\n      var first_type = this.types[first_key];\n      var valA = a[first_key];\n      var valB = b[first_key];\n      if (first_type.compare) return first_type.compare(valA, valB);\n      if (typeof valA === \"number\" && typeof valB === \"number\") return valA - valB;\n      var encoding = void 0;\n      if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {\n        // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.\n        encoding = \"hex\";\n      }\n      var strA = valA.toString(encoding);\n      var strB = valB.toString(encoding);\n      return strA > strB ? 1 : strA < strB ? -1 : 0;\n    }\n\n    // <helper_functions>\n  }, {\n    key: 'fromHex',\n    value: function fromHex(hex) {\n      var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);\n      return this.fromByteBuffer(b);\n    }\n  }, {\n    key: 'fromBuffer',\n    value: function fromBuffer(buffer) {\n      var b = ByteBuffer.fromBinary(buffer.toString(\"binary\"), ByteBuffer.LITTLE_ENDIAN);\n      return this.fromByteBuffer(b);\n    }\n  }, {\n    key: 'toHex',\n    value: function toHex(object) {\n      // return this.toBuffer(object).toString(\"hex\")\n      var b = this.toByteBuffer(object);\n      return b.toHex();\n    }\n  }, {\n    key: 'toByteBuffer',\n    value: function toByteBuffer(object) {\n      var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n      this.appendByteBuffer(b, object);\n      return b.copy(0, b.offset);\n    }\n  }, {\n    key: 'toBuffer',\n    value: function toBuffer(object) {\n      return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');\n    }\n  }]);\n  return Serializer;\n}();\nmodule.exports = Serializer;","map":{"version":3,"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","ByteBuffer","require","EC","HEX_DUMP","process","env","npm_config__graphene_serializer_hex_dump","Serializer","operation_name","types","keys","printDebug","value","fromByteBuffer","b","object","field","iterable","type","console","error","o1","offset","o2","_b","copy","toHex","e","throw","appendByteBuffer","JSON","stringify","fromObject","serialized_object","result","toObject","arguments","undefined","debug","use_default","annotate","DEFAULT_CAPACITY","LITTLE_ENDIAN","has_value","compare","a","first_key","first_type","valA","valB","encoding","Buffer","isBuffer","strA","toString","strB","fromHex","hex","fromBuffer","buffer","fromBinary","toByteBuffer","toBuffer","toBinary","module","exports"],"sources":["C:/Users/sunil/kalakaari/node_modules/@hiveio/hive-js/lib/auth/serializer/src/serializer.js"],"sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ByteBuffer = require('bytebuffer');\nvar EC = require('./error_with_cause');\n\nvar HEX_DUMP = process.env.npm_config__graphene_serializer_hex_dump;\n\nvar Serializer = function () {\n    function Serializer(operation_name, types) {\n        _classCallCheck(this, Serializer);\n\n        this.operation_name = operation_name;\n        this.types = types;\n        if (this.types) this.keys = Object.keys(this.types);\n\n        Serializer.printDebug = true;\n    }\n\n    _createClass(Serializer, [{\n        key: 'fromByteBuffer',\n        value: function fromByteBuffer(b) {\n            var object = {};\n            var field = null;\n            try {\n                var iterable = this.keys;\n                for (var i = 0, field; i < iterable.length; i++) {\n                    field = iterable[i];\n                    var type = this.types[field];\n                    try {\n                        if (HEX_DUMP) {\n                            if (type.operation_name) {\n                                console.error(type.operation_name);\n                            } else {\n                                var o1 = b.offset;\n                                type.fromByteBuffer(b);\n                                var o2 = b.offset;\n                                b.offset = o1;\n                                //b.reset()\n                                var _b = b.copy(o1, o2);\n                                console.error(this.operation_name + '.' + field + '\\t', _b.toHex());\n                            }\n                        }\n                        object[field] = type.fromByteBuffer(b);\n                    } catch (e) {\n                        if (Serializer.printDebug) {\n                            console.error('Error reading ' + this.operation_name + '.' + field + ' in data:');\n                            b.printDebug();\n                        }\n                        throw e;\n                    }\n                }\n            } catch (error) {\n                EC.throw(this.operation_name + '.' + field, error);\n            }\n\n            return object;\n        }\n    }, {\n        key: 'appendByteBuffer',\n        value: function appendByteBuffer(b, object) {\n            var field = null;\n            try {\n                var iterable = this.keys;\n                for (var i = 0, field; i < iterable.length; i++) {\n                    field = iterable[i];\n                    var type = this.types[field];\n                    type.appendByteBuffer(b, object[field]);\n                }\n            } catch (error) {\n                try {\n                    EC.throw(this.operation_name + '.' + field + \" = \" + JSON.stringify(object[field]), error);\n                } catch (e) {\n                    // circular ref\n                    EC.throw(this.operation_name + '.' + field + \" = \" + object[field], error);\n                }\n            }\n            return;\n        }\n    }, {\n        key: 'fromObject',\n        value: function fromObject(serialized_object) {\n            var result = {};\n            var field = null;\n            try {\n                var iterable = this.keys;\n                for (var i = 0, field; i < iterable.length; i++) {\n                    field = iterable[i];\n                    var type = this.types[field];\n                    var value = serialized_object[field];\n                    //DEBUG value = value.resolve if value.resolve\n                    //DEBUG console.log('... value',field,value)\n                    var object = type.fromObject(value);\n                    result[field] = object;\n                }\n            } catch (error) {\n                EC.throw(this.operation_name + '.' + field, error);\n            }\n\n            return result;\n        }\n\n        /**\n            @arg {boolean} [debug.use_default = false] - more template friendly\n            @arg {boolean} [debug.annotate = false] - add user-friendly information\n        */\n\n    }, {\n        key: 'toObject',\n        value: function toObject() {\n            var serialized_object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { use_default: false, annotate: false };\n\n            var result = {};\n            var field = null;\n            try {\n                if (!this.types) return result;\n\n                var iterable = this.keys;\n                for (var i = 0, field; i < iterable.length; i++) {\n                    field = iterable[i];\n                    var type = this.types[field];\n                    var object = type.toObject(typeof serialized_object !== \"undefined\" && serialized_object !== null ? serialized_object[field] : undefined, debug);\n                    result[field] = object;\n                    if (HEX_DUMP) {\n                        var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n                        var has_value = typeof serialized_object !== \"undefined\" && serialized_object !== null;\n                        if (has_value) {\n                            var value = serialized_object[field];\n                            if (value) type.appendByteBuffer(b, value);\n                        }\n                        b = b.copy(0, b.offset);\n                        console.error(this.operation_name + '.' + field, b.toHex());\n                    }\n                }\n            } catch (error) {\n                EC.throw(this.operation_name + '.' + field, error);\n            }\n\n            return result;\n        }\n\n        /** Sort by the first element in a operation */\n\n    }, {\n        key: 'compare',\n        value: function compare(a, b) {\n\n            var first_key = this.keys[0];\n            var first_type = this.types[first_key];\n\n            var valA = a[first_key];\n            var valB = b[first_key];\n\n            if (first_type.compare) return first_type.compare(valA, valB);\n\n            if (typeof valA === \"number\" && typeof valB === \"number\") return valA - valB;\n\n            var encoding = void 0;\n            if (Buffer.isBuffer(valA) && Buffer.isBuffer(valB)) {\n                // A binary string compare does not work.  If localeCompare is well supported that could replace HEX.  Performanance is very good so comparing HEX works.\n                encoding = \"hex\";\n            }\n\n            var strA = valA.toString(encoding);\n            var strB = valB.toString(encoding);\n            return strA > strB ? 1 : strA < strB ? -1 : 0;\n        }\n\n        // <helper_functions>\n\n    }, {\n        key: 'fromHex',\n        value: function fromHex(hex) {\n            var b = ByteBuffer.fromHex(hex, ByteBuffer.LITTLE_ENDIAN);\n            return this.fromByteBuffer(b);\n        }\n    }, {\n        key: 'fromBuffer',\n        value: function fromBuffer(buffer) {\n            var b = ByteBuffer.fromBinary(buffer.toString(\"binary\"), ByteBuffer.LITTLE_ENDIAN);\n            return this.fromByteBuffer(b);\n        }\n    }, {\n        key: 'toHex',\n        value: function toHex(object) {\n            // return this.toBuffer(object).toString(\"hex\")\n            var b = this.toByteBuffer(object);\n            return b.toHex();\n        }\n    }, {\n        key: 'toByteBuffer',\n        value: function toByteBuffer(object) {\n            var b = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n            this.appendByteBuffer(b, object);\n            return b.copy(0, b.offset);\n        }\n    }, {\n        key: 'toBuffer',\n        value: function toBuffer(object) {\n            return new Buffer(this.toByteBuffer(object).toBinary(), 'binary');\n        }\n    }]);\n\n    return Serializer;\n}();\n\nmodule.exports = Serializer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}